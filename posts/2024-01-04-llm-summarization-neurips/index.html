<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.34">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Lawrence Wu">
<meta name="dcterms.date" content="2024-01-04">

<title>LLM Summarization and NeurIPS Papers – Lawrence Wu</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/cookie-consent/cookie-consent.js"></script>
<link href="../../site_libs/cookie-consent/cookie-consent.css" rel="stylesheet">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-c8ad9e5dbd60b7b70b38521ab19b7da4.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-1957b0821fa71716de2bb648d64006cb.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-LN4GM4FVCJ"></script>

<script type="text/plain" cookie-consent="tracking">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-LN4GM4FVCJ', { 'anonymize_ip': true});
</script>

<script type="text/javascript" charset="UTF-8">
document.addEventListener('DOMContentLoaded', function () {
cookieconsent.run({
  "notice_banner_type":"simple",
  "consent_type":"implied",
  "palette":"light",
  "language":"en",
  "page_load_consent_levels":["strictly-necessary","functionality","tracking","targeting"],
  "notice_banner_reject_button_hide":false,
  "preferences_center_close_button_hide":false,
  "website_name":""
  ,
"language":"en"
  });
});
</script> 
  
<script>
  // Log script loading attempt
  console.log('Loading GitHub stars script');
  
  // Simple script loading for main website
  const scriptTag = document.createElement('script');
  scriptTag.src = '/js/github-stars.js';
  scriptTag.async = false;
  scriptTag.defer = true;
  scriptTag.onload = () => console.log('GitHub stars script loaded successfully');
  scriptTag.onerror = (err) => console.error('Error loading GitHub stars script:', err);
  
  // Append to document head
  document.head.appendChild(scriptTag);
</script>


<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="LLM Summarization and NeurIPS Papers – Lawrence Wu">
<meta property="og:description" content="This is Lawrence Wu’s personal website">
<meta property="og:site_name" content="Lawrence Wu">
<meta name="twitter:title" content="LLM Summarization and NeurIPS Papers – Lawrence Wu">
<meta name="twitter:description" content="This is Lawrence Wu’s personal website">
<meta name="twitter:creator" content="@law_wu">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Lawrence Wu</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../projects.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../conferences.html"> 
<span class="menu-text">Conferences</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://lawwu.github.io/til/"> 
<span class="menu-text">TIL</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://github.com/lawwu"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text">GitHub</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://twitter.com/law_wu"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text">Twitter</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="mailto:lawrencewu1+blog@gmail.com"> <i class="bi bi-envelope" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../blog.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#takeaways" id="toc-takeaways" class="nav-link active" data-scroll-target="#takeaways">Takeaways</a></li>
  <li><a href="#code" id="toc-code" class="nav-link" data-scroll-target="#code">Code</a></li>
  <li><a href="#llm-summaries" id="toc-llm-summaries" class="nav-link" data-scroll-target="#llm-summaries">LLM Summaries</a>
  <ul class="collapse">
  <li><a href="#test-of-time-paper-word2vec" id="toc-test-of-time-paper-word2vec" class="nav-link" data-scroll-target="#test-of-time-paper-word2vec">Test of Time Paper: Word2Vec</a>
  <ul class="collapse">
  <li><a href="#gpt-4" id="toc-gpt-4" class="nav-link" data-scroll-target="#gpt-4">gpt-4</a></li>
  <li><a href="#solar-10.7b" id="toc-solar-10.7b" class="nav-link" data-scroll-target="#solar-10.7b">solar-10.7b</a></li>
  </ul></li>
  <li><a href="#emergence-mirage" id="toc-emergence-mirage" class="nav-link" data-scroll-target="#emergence-mirage">Emergence Mirage</a>
  <ul class="collapse">
  <li><a href="#gpt-4-1" id="toc-gpt-4-1" class="nav-link" data-scroll-target="#gpt-4-1">gpt-4</a></li>
  <li><a href="#solar-10.7b-1" id="toc-solar-10.7b-1" class="nav-link" data-scroll-target="#solar-10.7b-1">solar-10.7b</a></li>
  </ul></li>
  <li><a href="#dpo" id="toc-dpo" class="nav-link" data-scroll-target="#dpo">DPO</a>
  <ul class="collapse">
  <li><a href="#gpt-4-2" id="toc-gpt-4-2" class="nav-link" data-scroll-target="#gpt-4-2">gpt-4</a></li>
  <li><a href="#solar-10.7b-2" id="toc-solar-10.7b-2" class="nav-link" data-scroll-target="#solar-10.7b-2">solar-10.7b</a></li>
  </ul></li>
  <li><a href="#dpo-poster-session" id="toc-dpo-poster-session" class="nav-link" data-scroll-target="#dpo-poster-session">DPO Poster Session</a>
  <ul class="collapse">
  <li><a href="#gpt-4-3" id="toc-gpt-4-3" class="nav-link" data-scroll-target="#gpt-4-3">gpt-4</a></li>
  <li><a href="#solar-10.7b-3" id="toc-solar-10.7b-3" class="nav-link" data-scroll-target="#solar-10.7b-3">solar-10.7b</a></li>
  </ul></li>
  <li><a href="#datablations" id="toc-datablations" class="nav-link" data-scroll-target="#datablations">Datablations</a>
  <ul class="collapse">
  <li><a href="#gpt-4-4" id="toc-gpt-4-4" class="nav-link" data-scroll-target="#gpt-4-4">gpt-4</a></li>
  <li><a href="#solar-10.7b-4" id="toc-solar-10.7b-4" class="nav-link" data-scroll-target="#solar-10.7b-4">solar-10.7b</a></li>
  </ul></li>
  <li><a href="#qlora" id="toc-qlora" class="nav-link" data-scroll-target="#qlora">QLoRA</a>
  <ul class="collapse">
  <li><a href="#gpt-4-5" id="toc-gpt-4-5" class="nav-link" data-scroll-target="#gpt-4-5">gpt-4</a></li>
  <li><a href="#solar-10.7b-5" id="toc-solar-10.7b-5" class="nav-link" data-scroll-target="#solar-10.7b-5">solar-10.7b</a></li>
  </ul></li>
  <li><a href="#datacomp" id="toc-datacomp" class="nav-link" data-scroll-target="#datacomp">DataComp</a>
  <ul class="collapse">
  <li><a href="#gpt-4-6" id="toc-gpt-4-6" class="nav-link" data-scroll-target="#gpt-4-6">gpt-4</a></li>
  <li><a href="#solar-10.7b-6" id="toc-solar-10.7b-6" class="nav-link" data-scroll-target="#solar-10.7b-6">solar-10.7b</a></li>
  </ul></li>
  <li><a href="#datacomp-poster-session" id="toc-datacomp-poster-session" class="nav-link" data-scroll-target="#datacomp-poster-session">DataComp Poster Session</a>
  <ul class="collapse">
  <li><a href="#gpt-4-7" id="toc-gpt-4-7" class="nav-link" data-scroll-target="#gpt-4-7">gpt-4</a></li>
  <li><a href="#solar-10.7b-7" id="toc-solar-10.7b-7" class="nav-link" data-scroll-target="#solar-10.7b-7">solar-10.7b</a></li>
  </ul></li>
  <li><a href="#llava" id="toc-llava" class="nav-link" data-scroll-target="#llava">LLaVA</a>
  <ul class="collapse">
  <li><a href="#gpt-4-8" id="toc-gpt-4-8" class="nav-link" data-scroll-target="#gpt-4-8">gpt-4</a></li>
  <li><a href="#solar-10.7b-8" id="toc-solar-10.7b-8" class="nav-link" data-scroll-target="#solar-10.7b-8">solar-10.7b</a></li>
  </ul></li>
  <li><a href="#llava-poster-session" id="toc-llava-poster-session" class="nav-link" data-scroll-target="#llava-poster-session">LLaVA Poster Session</a>
  <ul class="collapse">
  <li><a href="#gpt-4-9" id="toc-gpt-4-9" class="nav-link" data-scroll-target="#gpt-4-9">gpt-4</a></li>
  <li><a href="#solar-10.7b-9" id="toc-solar-10.7b-9" class="nav-link" data-scroll-target="#solar-10.7b-9">solar-10.7b</a></li>
  </ul></li>
  <li><a href="#tree-of-thought" id="toc-tree-of-thought" class="nav-link" data-scroll-target="#tree-of-thought">Tree of Thought</a>
  <ul class="collapse">
  <li><a href="#gpt-4-10" id="toc-gpt-4-10" class="nav-link" data-scroll-target="#gpt-4-10">gpt-4</a></li>
  <li><a href="#solar-10.7b-10" id="toc-solar-10.7b-10" class="nav-link" data-scroll-target="#solar-10.7b-10">solar-10.7b</a></li>
  </ul></li>
  <li><a href="#tree-of-thought-poster-session" id="toc-tree-of-thought-poster-session" class="nav-link" data-scroll-target="#tree-of-thought-poster-session">Tree of Thought Poster Session</a>
  <ul class="collapse">
  <li><a href="#gpt-4-11" id="toc-gpt-4-11" class="nav-link" data-scroll-target="#gpt-4-11">gpt-4</a></li>
  <li><a href="#solar-10.7b-11" id="toc-solar-10.7b-11" class="nav-link" data-scroll-target="#solar-10.7b-11">solar-10.7b</a></li>
  </ul></li>
  <li><a href="#toolformer" id="toc-toolformer" class="nav-link" data-scroll-target="#toolformer">Toolformer</a>
  <ul class="collapse">
  <li><a href="#gpt-4-12" id="toc-gpt-4-12" class="nav-link" data-scroll-target="#gpt-4-12">gpt-4</a></li>
  <li><a href="#solar-10.7b-12" id="toc-solar-10.7b-12" class="nav-link" data-scroll-target="#solar-10.7b-12">solar-10.7b</a></li>
  </ul></li>
  <li><a href="#voyager" id="toc-voyager" class="nav-link" data-scroll-target="#voyager">Voyager</a>
  <ul class="collapse">
  <li><a href="#gpt-4-13" id="toc-gpt-4-13" class="nav-link" data-scroll-target="#gpt-4-13">gpt-4</a></li>
  <li><a href="#solar-10.7b-13" id="toc-solar-10.7b-13" class="nav-link" data-scroll-target="#solar-10.7b-13">solar-10.7b</a></li>
  </ul></li>
  <li><a href="#cogeval" id="toc-cogeval" class="nav-link" data-scroll-target="#cogeval">CogEval</a>
  <ul class="collapse">
  <li><a href="#gpt-4-14" id="toc-gpt-4-14" class="nav-link" data-scroll-target="#gpt-4-14">gpt-4</a></li>
  <li><a href="#solar-10.7b-14" id="toc-solar-10.7b-14" class="nav-link" data-scroll-target="#solar-10.7b-14">solar-10.7b</a></li>
  </ul></li>
  <li><a href="#state-space-models" id="toc-state-space-models" class="nav-link" data-scroll-target="#state-space-models">State Space Models</a>
  <ul class="collapse">
  <li><a href="#gpt-4-15" id="toc-gpt-4-15" class="nav-link" data-scroll-target="#gpt-4-15">gpt-4</a></li>
  <li><a href="#solar-10.7b-15" id="toc-solar-10.7b-15" class="nav-link" data-scroll-target="#solar-10.7b-15">solar-10.7b</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">LLM Summarization and NeurIPS Papers</h1>
  <div class="quarto-categories">
    <div class="quarto-category">LLMs</div>
    <div class="quarto-category">Summarization</div>
    <div class="quarto-category">NeurIPS</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Lawrence Wu </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 4, 2024</p>
    </div>
  </div>
  
    <div>
    <div class="quarto-title-meta-heading">Modified</div>
    <div class="quarto-title-meta-contents">
      <p class="date-modified">January 4, 2024</p>
    </div>
  </div>
    
  </div>
  


</header>


<p>I didn’t get the chance to attend NeurIPS last week. The sheer number of papers submitted is <a href="https://blog.neurips.cc/tag/neurips2023/">staggering</a>: 13,300 submitted papers that were reviewed by 1,000+ people. 3,540 papers were accepted and 502 papers were flagged for ethics reviews!</p>
<p>The folks at the Latent Space podcast did a good job summarizing the wealth of content, one reviewing the <a href="https://podcasts.google.com/feed/aHR0cHM6Ly93d3cubGF0ZW50LnNwYWNlL2ZlZWQ/episode/aHR0cHM6Ly93d3cubGF0ZW50LnNwYWNlL3AvbmV1cmlwcy0yMDIzLXBhcGVycw?sa=X&amp;ved=0CAUQkfYCahcKEwiYzPGz7LiDAxUAAAAAHQAAAAAQOw">best papers</a> and another that was focused on <a href="https://podcasts.google.com/feed/aHR0cHM6Ly93d3cubGF0ZW50LnNwYWNlL2ZlZWQ/episode/aHR0cHM6Ly93d3cubGF0ZW50LnNwYWNlL3AvbmV1cmlwcy0yMDIzLXN0YXJ0dXBz?sa=X&amp;ved=0CAUQkfYCahcKEwj4-6rNmcODAxUAAAAAHQAAAAAQCg">top startups</a>.</p>
<p>I transcribed these podcasts using Whisper and tried taking a stab at summarizing them. Those transcripts are here:</p>
<ul>
<li><a href="./neurips_papers_2023.wav.txt">Latent Space Top Papers Transcript</a></li>
<li><a href="./neurips_startups_2023.wav.txt">Latent Space Top Startups Transcript</a></li>
</ul>
<p>The podcast comes with timestamps for each section which is very helpful:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> [</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    {<span class="st">"time"</span>: <span class="st">"0:01:19"</span>, <span class="st">"title"</span>: <span class="st">"Word2Vec"</span>, <span class="st">"presenter"</span>: [<span class="st">"Jeff Dean"</span>, <span class="st">"Greg Corrado"</span>]},</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    {<span class="st">"time"</span>: <span class="st">"0:15:28"</span>, <span class="st">"title"</span>: <span class="st">"Emergence Mirage"</span>, <span class="st">"presenter"</span>: [<span class="st">"Rylan Schaeffer"</span>]},</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    {<span class="st">"time"</span>: <span class="st">"0:28:48"</span>, <span class="st">"title"</span>: <span class="st">"DPO"</span>, <span class="st">"presenter"</span>: [<span class="st">"Rafael Rafailov"</span>]},</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    {<span class="st">"time"</span>: <span class="st">"0:41:36"</span>, <span class="st">"title"</span>: <span class="st">"DPO Poster Session"</span>, <span class="st">"presenter"</span>: [<span class="st">"Archit Sharma"</span>]},</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    {<span class="st">"time"</span>: <span class="st">"0:52:03"</span>, <span class="st">"title"</span>: <span class="st">"Datablations"</span>, <span class="st">"presenter"</span>: [<span class="st">"Niklas Muennighoff"</span>]},</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    {<span class="st">"time"</span>: <span class="st">"1:00:50"</span>, <span class="st">"title"</span>: <span class="st">"QLoRA"</span>, <span class="st">"presenter"</span>: [<span class="st">"Tim Dettmers"</span>]},</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    {<span class="st">"time"</span>: <span class="st">"1:12:23"</span>, <span class="st">"title"</span>: <span class="st">"DataComp"</span>, <span class="st">"presenter"</span>: [<span class="st">"Samir Gadre"</span>]},</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    {<span class="st">"time"</span>: <span class="st">"1:25:38"</span>, <span class="st">"title"</span>: <span class="st">"DataComp Poster Session"</span>, <span class="st">"presenter"</span>: [<span class="st">"Samir Gadre"</span>, <span class="st">"Alex Dimakis"</span>]},</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    {<span class="st">"time"</span>: <span class="st">"1:35:25"</span>, <span class="st">"title"</span>: <span class="st">"LLaVA"</span>, <span class="st">"presenter"</span>: [<span class="st">"Haotian Liu"</span>]},</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    {<span class="st">"time"</span>: <span class="st">"1:47:21"</span>, <span class="st">"title"</span>: <span class="st">"LLaVA Poster Session"</span>, <span class="st">"presenter"</span>: [<span class="st">"Haotian Liu"</span>]},</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    {<span class="st">"time"</span>: <span class="st">"1:59:19"</span>, <span class="st">"title"</span>: <span class="st">"Tree of Thought"</span>, <span class="st">"presenter"</span>: [<span class="st">"Shunyu Yao"</span>]},</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    {<span class="st">"time"</span>: <span class="st">"2:11:27"</span>, <span class="st">"title"</span>: <span class="st">"Tree of Thought Poster Session"</span>, <span class="st">"presenter"</span>: [<span class="st">"Shunyu Yao"</span>]},</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    {<span class="st">"time"</span>: <span class="st">"2:20:09"</span>, <span class="st">"title"</span>: <span class="st">"Toolformer"</span>, <span class="st">"presenter"</span>: [<span class="st">"Jane Dwivedi-Yu"</span>]},</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    {<span class="st">"time"</span>: <span class="st">"2:32:26"</span>, <span class="st">"title"</span>: <span class="st">"Voyager"</span>, <span class="st">"presenter"</span>: [<span class="st">"Guanzhi Wang"</span>]},</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    {<span class="st">"time"</span>: <span class="st">"2:45:14"</span>, <span class="st">"title"</span>: <span class="st">"CogEval"</span>, <span class="st">"presenter"</span>: [<span class="st">"Ida Momennejad"</span>]},</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    {<span class="st">"time"</span>: <span class="st">"2:59:41"</span>, <span class="st">"title"</span>: <span class="st">"State Space Models"</span>, <span class="st">"presenter"</span>: [<span class="st">"Chris Ré"</span>]}</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For all the LLM generations, I used the following prompt:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>Summarize the following transcript of a podcast <span class="kw">in</span> a couple paragraphs at most: {text}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="takeaways" class="level1">
<h1>Takeaways</h1>
<p>My main learnings through this effort are:</p>
<ul>
<li>Whisper is a fantastic transcription tool and running this locally on a Mac using whisper.cpp is quite feasible because the quantized models are small</li>
<li>I tried various open source LLMs for summarization and they all had trouble generating decent summaries consistently. Some of the issues were
<ul>
<li>summaries are empty strings</li>
<li>summaries are generated after repeating the text</li>
<li>hallucinations</li>
</ul></li>
<li>Some of the models I tried:
<ul>
<li><code>solar-10.7b-instruct-v1.0.Q8_0.gguf</code></li>
<li><code>mixtral-8x7b-instruct-v0.1.Q5_K_M.gguf</code></li>
<li><code>mistral-7b-instruct-v0.2.Q8_0.gguf</code></li>
<li><code>llama-2-13b-chat.Q8_0.gguf</code></li>
<li><code>inkbot-13b-8k-0.2.Q8_0.gguf</code></li>
</ul></li>
<li>gpt-4 is (not surprisingly at this point) able to generate decent summaries consistently</li>
</ul>
</section>
<section id="code" class="level1">
<h1>Code</h1>
<p>To generate summaries using a local LLM, you can use the following code:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> langchain.callbacks.manager <span class="im">import</span> CallbackManager</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> langchain.callbacks.streaming_stdout <span class="im">import</span> StreamingStdOutCallbackHandler</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> langchain.llms <span class="im">import</span> LlamaCpp</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> logging</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> load_llm_llamacpp(</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    model_name,</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    model_dir,</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    temperature<span class="op">=</span><span class="fl">0.2</span>,</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    top_p<span class="op">=</span><span class="dv">1</span>,</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    max_tokens<span class="op">=</span><span class="dv">2048</span>,</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    n_ctx<span class="op">=</span><span class="dv">8000</span>,</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    repeat_penalty<span class="op">=</span><span class="fl">1.1</span>,</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    n_threads<span class="op">=</span><span class="dv">8</span>,</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    callback_manager<span class="op">=</span>CallbackManager([StreamingStdOutCallbackHandler()]),</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    n_gpu_layers<span class="op">=</span><span class="dv">1</span>,</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    n_batch<span class="op">=</span><span class="dv">8000</span>,</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    f16_kv<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    verbose<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">**</span>kwargs,</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a><span class="co">    Loads a LlamaCpp model from the model directory with</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a><span class="co">    default parameters for an Apple Silicon Mac</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>    model_path <span class="op">=</span> <span class="bu">str</span>(model_dir <span class="op">/</span> model_name)</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>    llm_llamacpp <span class="op">=</span> LlamaCpp(</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>        <span class="co"># model_path has to take a str not a pathlib.Path</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>        model_path<span class="op">=</span>model_path,</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>        temperature<span class="op">=</span>temperature,</span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>        top_p<span class="op">=</span>top_p,</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>        max_tokens<span class="op">=</span>max_tokens,</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>        n_ctx<span class="op">=</span>n_ctx,</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>        repeat_penalty<span class="op">=</span>repeat_penalty,</span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>        n_threads<span class="op">=</span>n_threads,</span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>        callback_manager<span class="op">=</span>callback_manager,</span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>        n_gpu_layers<span class="op">=</span>n_gpu_layers,  <span class="co"># Metal set to 1 is enough.</span></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>        <span class="co"># n_batch should be between 1 and n_ctx</span></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>        n_batch<span class="op">=</span>n_batch,</span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>        <span class="co"># f16_kv MUST set to True,</span></span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>        <span class="co"># otherwise you will run into problem after a couple of calls</span></span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>        f16_kv<span class="op">=</span>f16_kv,</span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>        verbose<span class="op">=</span>verbose,</span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>        <span class="op">**</span>kwargs,</span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> llm_llamacpp</span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a>llm_solar_10b <span class="op">=</span> load_llm_llamacpp(</span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a>    model_dir <span class="op">=</span> Path(<span class="st">"/Users/lawrencewu/github/research-llms/models/"</span>),</span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a>    model_name <span class="op">=</span> <span class="st">"solar-10.7b-instruct-v1.0.Q8_0.gguf"</span></span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> section <span class="kw">in</span> data:</span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Section: </span><span class="sc">{</span>section[<span class="st">'title'</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a>    prompt <span class="op">=</span> <span class="ss">f"Summarize the following transcript of a podcast in a couple paragraphs at most: </span><span class="sc">{</span>section[<span class="st">'text'</span>]<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a>    section[<span class="st">"summary_solar_10b"</span>] <span class="op">=</span> llm_solar_10b(prompt)</span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Summary: </span><span class="sc">{</span>section[<span class="st">'summary_solar_10b'</span>]<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="llm-summaries" class="level1">
<h1>LLM Summaries</h1>
<p>The summaries below are generated by <code>solar-10.7b-instruct-v1.0.Q8_0.gguf</code> and gpt-4. Some of the summaries are quite good like the one for Word2Vec and Emergence Mirage. However, some issues with most of the summaries:</p>
<ul>
<li>the LLM looks like it is repeating text verbatim from the source text</li>
<li>in some cases a summary is not generated at all</li>
<li>sometimes the summary is generated after repeating the text</li>
<li>there are hallucinations too</li>
</ul>
<p>For reference I also generated summaries using gpt-4 which is a strong comparison.</p>
<section id="test-of-time-paper-word2vec" class="level2">
<h2 class="anchored" data-anchor-id="test-of-time-paper-word2vec">Test of Time Paper: Word2Vec</h2>
<section id="gpt-4" class="level3">
<h3 class="anchored" data-anchor-id="gpt-4">gpt-4</h3>
<p>The podcast transcript features Jeff and Greg, who reflect on their influential work in natural language processing (NLP) and machine learning, initially presented at the ICLR 2013 workshop. They begin by discussing the early stages of their research, which focused on various loss functions and optimization techniques for word embedding representations. A key discovery from this period was the effectiveness of the skip-gram model in comparison to other models they evaluated. This led to a concentrated effort on enhancing the skip-gram model, including improvements in optimization and the introduction of phrase embeddings. Ilya, a later addition to their team, contributed significantly to the paper’s influence.</p>
<p>Throughout the talk, Jeff and Greg highlight several key learnings from their work. They emphasize the importance of semi-supervised objectives in natural language understanding, noting the potential of semi-supervised learning to leverage large, unlabeled data sets for constructing supervised-like training data. Another significant point is the superiority of fast, parallel, and weakly supervised computation over more tightly synchronized approaches, which has become a dominant trend in machine learning. They also discuss the relevance of tokenization in solving nuanced problems and the unexpected power of treating language as sequences of dense vectors.</p>
<p>Jeff and Greg conclude by revisiting the main themes of their research and its current relevance. They acknowledge the shift in ML towards more synchronized approaches but foresee a potential resurgence of asynchronous methods for training large models. They also touch on the evolution of tokenization methods and the continued significance of representing language through dense vectors. The podcast ends with an acknowledgment of their co-authors and a mention of the “Test of Time” award, suggesting the sequence-to-sequence paper as a likely winner for its influence on language models. They also tease the potential award winner for 2027 and mention the “Mirage” paper as a significant work for AI engineers.</p>
</section>
<section id="solar-10.7b" class="level3">
<h3 class="anchored" data-anchor-id="solar-10.7b">solar-10.7b</h3>
<p>Summary: The podcast discusses a retrospective on a research work that focused on optimizing word embedding representations using the skip-gram model and interesting optimization techniques for phrase embeddings. The paper has been widely cited, with source code and trained representations being used by many in various applications. Key themes from this work include the powerful potential of semi-supervised objectives, treating language as a sequence of dense vectors, and the effective use of weakly synchronized, asynchronous updates to scale large models. The paper also explores how tokenization can be utilized for solving nuanced problems and highlights the importance of focusing compute on aspects that need improvement. This research has significantly impacted natural language understanding and continues to resonate in today’s AI landscape.</p>
</section>
</section>
<section id="emergence-mirage" class="level2">
<h2 class="anchored" data-anchor-id="emergence-mirage">Emergence Mirage</h2>
<section id="gpt-4-1" class="level3">
<h3 class="anchored" data-anchor-id="gpt-4-1">gpt-4</h3>
<p>The podcast transcript covers a presentation on the paper “Our Emergent Abilities of Large Language Models, a Mirage,” co-authored by Brando Miranda and Professor Sanmi Koyejo. The paper critically examines the concept of “emergent abilities” in large language models (LLMs), which refers to capabilities that appear in larger models but are absent in smaller ones. These abilities were thought to be unpredictable based on the performance of smaller models. The authors argue, however, that these emergent abilities might not be due to fundamental changes in model scale but rather the result of the metrics used to evaluate these models.</p>
<p>The paper challenges the notion of emergent abilities by proposing that the way models are evaluated, especially using harsh, non-linear metrics like exact match or multiple-choice grade, may create an illusion of emergent abilities. They suggest that if metrics were more continuous and linear, like edit distance or Breyer’s score, the scaling of model performance would appear more predictable and less like emergent phenomena.</p>
<p>To support their hypothesis, the authors conducted three types of evidence: predictions using the GPT-3 model, a meta-analysis of published metrics and emergent abilities at Google’s Big Bench, and an experiment inducing emergent abilities in small networks on vision tasks. Their findings suggest that emergent abilities could be more a matter of evaluation methodology than a fundamental property of large-scale models.</p>
<p>The podcast concludes with reflections on the paper’s reception. Despite its recognition as the best paper, there’s a hint of skepticism about its impact on the field. It’s suggested that while the paper is notable and well-executed, it might not have fundamentally altered understandings or practices in the field of machine learning, primarily addressing methodological issues rather than denying the existence of emergent phenomena in large language models.</p>
</section>
<section id="solar-10.7b-1" class="level3">
<h3 class="anchored" data-anchor-id="solar-10.7b-1">solar-10.7b</h3>
<p>Summary: The discussed podcast presents research on predictability and surprise in large language models, specifically addressing the concept of emergent abilities. This study, conducted by Brando Miranda and Professor Sanmi Koyejo, challenges the narrative around sudden improvements in model performance at seemingly unpredictable scales. It argues that these emergent abilities might not be due to fundamental changes in the models but rather a result of how we evaluate them.</p>
<p>The researchers propose an alternative hypothesis where they demonstrate that non-linear and discontinuous evaluation metrics can create the illusion of emergent abilities. They provide evidence from GPT-3, Google’s Big Bench, and toy minuscule networks on vision tasks to support their claim. The paper highlights the importance of considering scaling properties, evaluation data quality, and specific metrics when predicting changes in model capabilities with increasing scale. Despite being a notable contribution to the field, its impact as the “best paper” is questioned due to not directly denying emergence’s existence but rather pointing out methodological disagreements.</p>
</section>
</section>
<section id="dpo" class="level2">
<h2 class="anchored" data-anchor-id="dpo">DPO</h2>
<section id="gpt-4-2" class="level3">
<h3 class="anchored" data-anchor-id="gpt-4-2">gpt-4</h3>
<p>The podcast discusses “Direct Preference Optimization” (DPO), an algorithm that simplifies Reinforcement Learning from Human Feedback (RLHF), a framework increasingly popular in large language models (LLMs). Eric, Raphael, and Archit explain that the emergence of models like GPT-3 and Chad GPT highlighted the importance of RLHF, which aligns model behavior with human expectations and desires.</p>
<p>The traditional RLHF pipeline involves two main steps: first, collecting a dataset of preferences (prompt and response pairs) and training a reward model based on these preferences, and second, optimizing a policy to maximize rewards while staying close to the initial supervised model. This process, typically employing Proximal Policy Optimization (PPO), is complex and resource-intensive.</p>
<p>DPO, in contrast, aims to streamline this process by finding a closed-form optimal solution for the optimization set up for RLHF. It utilizes the concept of the Boltzmann distribution to reweight the reference distribution by the exponentiated reward. DPO fits a reward model to preference data, skipping the reinforcement learning process altogether. The key to DPO is its use of a specific parameterization for the reward model, which directly yields the optimal policy for the RLHF objective without requiring a separate reinforcement learning step.</p>
<p>Their experiments show that DPO offers better reward-divergence trade-offs than PPO and other RL-free approaches, demonstrating its efficiency and stability across various tasks, including summarization and dialogue. Interestingly, DPO also shows comparable or better generalization capabilities than PPO-trained policies, even with limited training data.</p>
<p>The podcast concludes with the observation that while DPO is simpler, cheaper, and easier to train than PPO, there is some skepticism about its performance in terms of alignment and benchmark results compared to PPO-trained models. However, the potential benefits of DPO, especially in terms of computational efficiency, make it a noteworthy development in the field of machine learning and language model training.</p>
</section>
<section id="solar-10.7b-2" class="level3">
<h3 class="anchored" data-anchor-id="solar-10.7b-2">solar-10.7b</h3>
<p>Summary:</p>
</section>
</section>
<section id="dpo-poster-session" class="level2">
<h2 class="anchored" data-anchor-id="dpo-poster-session">DPO Poster Session</h2>
<section id="gpt-4-3" class="level3">
<h3 class="anchored" data-anchor-id="gpt-4-3">gpt-4</h3>
<p>The podcast discusses Direct Reference Optimization (DPO), an algorithm designed to simplify Reinforcement Learning from Human Feedback (RLHF). DPO streamlines the traditional RLHF pipeline, which is complex and hard to implement due to its reliance on reinforcement learning (RL) processes. RLHF, used in models like Chat GPT, starts with a base model and adds human preference data (pairwise comparisons of completions) to train a reward model. This model is then used to generate completions that maximize expected reward under a KL constraint to stay close to the initial distribution, preventing model degeneration.</p>
<p>DPO’s contribution lies in providing an exact optimal solution for this optimization problem. It reweights the reference distribution by exponentiating the reward, a concept derived from the Boltzmann distribution. The DPO approach involves rewriting the reward in terms of the policy itself, using a specific algebraic rearrangement. This results in a classification loss directly in terms of the fine-tuned policy, thereby eliminating the need for a separate RL optimization process.</p>
<p>The podcast reveals that DPO is advantageous because it requires only one step and uses the same preference dataset as RLHF. Experiments show DPO works effectively on real-world datasets, offering comparable or better results than PPO with greater efficiency. Additionally, the speaker discusses the developmental process of the paper, mentioning the crucial input from Chelsea Finn, and the inspiration behind the idea, emphasizing the advantages of removing steps in sequential learning. While DPO has shown promise, there are still areas for further research, particularly regarding its application in scenarios where reward models are trained on more complex datasets than binary pairwise preferences.</p>
</section>
<section id="solar-10.7b-3" class="level3">
<h3 class="anchored" data-anchor-id="solar-10.7b-3">solar-10.7b</h3>
<p>Summary: So we’re going to talk about the scaling laws here, but also what they did with their data augmentation techniques, which is a very interesting part of this paper as well.</p>
</section>
</section>
<section id="datablations" class="level2">
<h2 class="anchored" data-anchor-id="datablations">Datablations</h2>
<section id="gpt-4-4" class="level3">
<h3 class="anchored" data-anchor-id="gpt-4-4">gpt-4</h3>
<p>The podcast features Niklas presenting a study on “Scaling Data-Constrained Language Models.” The premise of the work is the increasing scarcity of high-quality language data, such as academic papers and books, and explores solutions for training large language models (LLMs) under data constraints. The study challenges the common practice in LLM training of avoiding data repetition, a norm in models like GPT-3 and Palm.</p>
<p>The research examines the effects of training for multiple epochs with repeated data. Initial findings indicate that training for a few epochs with repeated data yields similar performance to training with unique data. However, as the number of epochs increases, performance diverges negatively. This suggests that repeating data up to a certain limit (around four epochs) is feasible for scaling LLMs within existing data constraints.</p>
<p>The study also explores how to allocate computational resources when repeating data. Contrary to previous findings (such as those from the Chinchilla study), which recommend equal scaling of model size and training data, this research suggests that data should be scaled faster in repeated regimes. They demonstrate that models with fewer parameters trained for more epochs perform better both in terms of loss and downstream performance.</p>
<p>Additionally, the study investigates complementary strategies for data constraints, such as incorporating code data from sources like GitHub and employing filtering strategies like fuzzy deduplication and perplexity filtering. These methods show promise in improving model performance, even when repeating data.</p>
<p>Niklas concludes with key takeaways: Repeating data for up to four epochs is generally effective, adding code data can be beneficial even for natural language tasks, and quality filtering combined with data repetition can yield superior results compared to using the original dataset alone. He also highlights the practical application of these findings in training large language models, like FinGBT, a Finnish language model.</p>
<p>The podcast host remarks on the surprising finding that training up to four epochs is nearly as effective as using new data, challenging the notion that “One Epoch is All You Need.” The host appreciates the study’s contribution to open-source AI research, particularly noting Hugging Face’s exemplary work in documenting and sharing their research and methodologies.</p>
</section>
<section id="solar-10.7b-4" class="level3">
<h3 class="anchored" data-anchor-id="solar-10.7b-4">solar-10.7b</h3>
<p>Summary:</p>
</section>
</section>
<section id="qlora" class="level2">
<h2 class="anchored" data-anchor-id="qlora">QLoRA</h2>
<section id="gpt-4-5" class="level3">
<h3 class="anchored" data-anchor-id="gpt-4-5">gpt-4</h3>
<p>In the podcast, Tim Detmers presents QLORA, an efficient method for fine-tuning quantized large language models (LLMs). The key innovation of QLORA is its ability to compress neural networks to 4-bit while maintaining 16-bit performance, making it possible for regular researchers to fine-tune large language models without needing extensive GPU resources.</p>
<p>QLORA’s approach involves quantization, where a 32-bit float number is compressed to a 4-bit integer. This process involves slicing the distribution of values into 16 slices or bins, each representing a quantization bin. The main challenge in quantization is minimizing quantization errors to avoid degrading neural network performance.</p>
<p>In terms of fine-tuning costs, Detmers explains the high memory requirements for traditional methods, especially for models with billions of parameters. QLORA significantly reduces this footprint by quantizing the pre-trained model to 4-bit and adding adapters, which leads to a much smaller memory requirement, making it feasible to fine-tune on consumer-grade GPUs.</p>
<p>QLORA introduces several innovations, including a 4-bit normal float data type that is information-theoretically optimal and a double quantization technique for further memory reduction. In experiments, QLORA replicated 16-bit performance with 4-bit quantization across various models and datasets.</p>
<p>The podcast also highlights the development of Gonako, a high-quality chatbot created using QLORA. Gonako was fine-tuned on a single consumer GPU for 24 hours and compared favorably with other chatbots like ChatGPT in a tournament-style setup judged by humans and GPT-4.</p>
<p>Detmers concludes by noting that QLORA makes fine-tuning 18 times cheaper and has been integrated into the Hugging Face Transformer stack, making it accessible for widespread use. He also mentions his availability on the academic job market and an upcoming talk on the making of QLORA. The podcast then transitions to discussing the benefits of attending conferences like NeurIPS, where attendees can discover new and lesser-known research efforts.</p>
</section>
<section id="solar-10.7b-5" class="level3">
<h3 class="anchored" data-anchor-id="solar-10.7b-5">solar-10.7b</h3>
<p>Summary: So let’s hear about it from the horse’s mouth. Today, I will present our work on Datacomp, a new approach to multimodal learning that combines data-driven and model-based methods. Our goal is to enable models to learn to generate images conditioned on text descriptions in a data-efficient manner. To achieve this, we propose an algorithm that iteratively improves the quality of generated images by combining data-driven and model-based approaches. Data-driven methods train generative models using large amounts of paired image-text data. However, collecting such data is expensive and time consuming. Model-based methods generate images conditioned on text descriptions by optimizing latent codes with gradient descent. These methods can be trained without any paired data, but they often produce low quality results due to the difficulty of optimizing high dimensional spaces. Our approach combines these two approaches to improve image generation quality while reducing the need for paired data. We first train a model-based generator using an unpaired dataset of images and text descriptions. Then we use this generator to create synthetic paired data by generating images conditioned on text prompts. Next, we fine-tune a diffusion model with this synthetic data. Finally, we improve the quality of generated images by optimizing latent codes with gradient descent using the fine-tuned diffusion model as an oracle. Our experiments show that our approach improves image generation quality compared to both data-driven and model-based methods alone. We also demonstrate that our method can generate high quality results even when trained on a small number of real paired examples, making it more data efficient than purely data-driven approaches. In this talk, I will first introduce the problem of multimodal learning and discuss existing approaches to text-to-image generation. Then I will present our Datacomp algorithm in detail. Finally, I will show experimental results comparing our approach to baselines. Multimodal learning aims to enable machines to understand and generate information across different modalities such as images, audio, and text. One important application of multimodal learning is text-to-image generation, where the goal is to generate an image given a natural language description. This task has received significant attention in recent years due to its potential applications in various domains such as art, education, and gaming. Existing approaches to text-to-image generation can be broadly categorized into two main groups– data-driven methods and model-based methods. Data-driven methods learn a generative model by training on large datasets of paired image-text examples. These methods have achieved impressive results in recent years, but they require a significant amount of labeled data to train effectively. Collecting such data can be expensive and time consuming. Model-based methods, on the other hand, generate images conditioned on text descriptions by optimizing latent codes with gradient descent. These methods do not require any paired data for training, but they often produce low quality results due to the difficulty of optimizing high dimensional spaces. Our approach combines these two approaches to improve image generation quality while reducing the need for paired data. We first train a model-based generator using an unpaired dataset of images and text descriptions. Then we use this generator to create synthetic paired data by generating images conditioned on text prompts. Next, we fine-tune a diffusion model with this synthetic data. Finally, we improve the quality of generated images by optimizing latent codes with gradient descent using the fine-tuned diffusion model as an oracle. Let’s dive into our approach in more detail. Our algorithm consists of three main steps– pretraining a model-based generator, creating synthetic paired data, and fine-tuning a diffusion model. In the first step, we train a model-based generator using an unpaired dataset of images and text descriptions. We use CLIP to align the image and text encoders during training. This helps the generator to produce images that are relevant to the given text prompt. Next, we create synthetic paired data by generating images conditioned on text prompts using our pretrained model-based generator. These synthetic examples can be used to fine-tune a diffusion model in the next step. We use few real paired examples as additional supervision during fine-tuning to improve the quality of generated images. Finally, we optimize latent codes with gradient descent using the fine-tuned diffusion model as an oracle to further refine the generated images. Our experiments show that our approach improves image generation quality compared to both data-driven and model-based methods alone. We also demonstrate that our method can generate high quality results even when trained on a small number of real paired examples, making it more data efficient than purely data-driven approaches. In conclusion, we presented Datacomp, a new approach to multimodal learning that combines data-driven and model-based methods to improve image generation quality while reducing the need for paired data. Our experiments show promising results, highlighting the potential of our method in improving text-to-image generation. Thank you. [APPLAUSE]</p>
</section>
</section>
<section id="datacomp" class="level2">
<h2 class="anchored" data-anchor-id="datacomp">DataComp</h2>
<section id="gpt-4-6" class="level3">
<h3 class="anchored" data-anchor-id="gpt-4-6">gpt-4</h3>
<p>Samir, Gabriel Iliarco, and Alex Fang present their work “Datacomp: In Search of the Next Generation of Multimodal Datasets,” which focuses on the development of more efficient and powerful datasets for training large language models (LLMs), particularly in the field of computer vision. They emphasize the evolution from traditional supervised datasets, which required creating new datasets for new tasks, to the more flexible image-text datasets enabling open vocabulary models capable of various classification tasks.</p>
<p>Datacomp proposes a shift from the standard machine learning pipeline, which focuses on iterating on model architectures, to iterating on datasets instead. The core of Datacomp is a benchmark for dataset development, especially focusing on the CLIP training regime for image-text datasets. CLIP uses a text encoder and an image encoder trained contrastively to align image and text representations.</p>
<p>Datacomp’s workflow comprises five steps: choosing a scale, selecting data, training a model, evaluating, and submitting results. It offers flexibility in data selection, allowing participants to filter from a provided raw data pool or bring additional data. The workflow uses fixed training recipes for CLIP training and evaluates models on a suite of 38 downstream tasks.</p>
<p>Gabriel discusses experiments with different baselines, particularly focusing on clip score filtering and image-based filtering. The best-performing baseline, DataComp1B, is a 1.4 billion sample subset of the data pool, showing higher accuracy than existing datasets, including OpenAI’s. This demonstrates that carefully selecting and filtering smaller data subsets can yield better performance than using larger, noisier datasets.</p>
<p>DataComp encourages community participation, even for those with limited computational resources. It is fully open source, with resources including a website, codebase, and paper available for anyone interested. The project represents a significant step in refining dataset creation and selection, shifting the focus in LLM training from merely scaling models to designing more effective datasets.</p>
</section>
<section id="solar-10.7b-6" class="level3">
<h3 class="anchored" data-anchor-id="solar-10.7b-6">solar-10.7b</h3>
<p>In this podcast, Samir, Gabriel, and Alex discuss their paper “Datacomp: In Search of the Next Generation of Multimodal Datasets.” They explain how traditional computer vision models have been improved through specialized data sets, but this process can be laborious. The paradigm shifted to image text datasets that allowed for open-vocabulary trading models, enabling downstream tasks like image classification. However, the standard machine learning pipeline remained consistent: create a monolithic artifact (data set), keep it fixed, and iterate on model training. They introduce Data Comp as a benchmark for data set development to understand how data set decisions improve models. This focuses on CLIP trading regimes for modern image text datasets, where they fix the CLIP bit and iterate on data selection processes to create new data sets for CLIP model training. The Data Comp workflow consists of five steps: choosing a scale, selecting data, training a model, evaluating, and submitting results. Participants can use their data selection method on either a fixed provided pool or bring in additional data. They then train a model using a fixed recipe with hyperparameters for CLIP training. Models are evaluated using a suite of 38 downstream tasks, and the final step is to submit results. The authors study various baselines, including clip score filtering and image-based filtering, which they intersect to create DataComp1B, a data set that outperforms existing data sets like OpenAI’s WIT and Lion2B at no extra cost during training time. They find smaller, more aggressively filtered data sets can perform better than larger ones from the same pool, and the ranking of filtering strategies is relatively stable across scales. Data Comp encourages experimentation with data sets to improve performance on downstream models, potentially becoming a new standard like ImageNet.</p>
</section>
</section>
<section id="datacomp-poster-session" class="level2">
<h2 class="anchored" data-anchor-id="datacomp-poster-session">DataComp Poster Session</h2>
<section id="gpt-4-7" class="level3">
<h3 class="anchored" data-anchor-id="gpt-4-7">gpt-4</h3>
<p>Samir, Gabriel Iliarco, and Alex Fang present “Datacomp: In Search of the Next Generation of Multimodal Datasets,” a project aimed at improving dataset development for large language models, particularly in computer vision. The team, comprising individuals from various universities and corporations, was brought together by Ludwig, known for his networking and openness to collaboration. Datacomp began as a benchmark for dataset development, focusing on the CLIP training regime, but evolved into a community-building initiative around dataset curation.</p>
<p>The Datacomp workflow consists of five steps: choosing a scale, selecting data, training a model, evaluating, and submitting results. Participants can filter data from a provided raw pool or bring in additional data. The project emphasizes dataset selection’s impact on model performance, encouraging experimentation with different data curation methods.</p>
<p>The team conducted over 300 pre-training experiments with various filtering strategies. One successful approach involved intersecting clip score filtering and image-based filtering to create DataComp1B, a 1.4 billion sample dataset that outperforms existing datasets. Their findings suggest smaller, carefully curated datasets can be more effective than larger, noisier ones.</p>
<p>Datacomp aims to shift the focus from scaling models to designing better datasets. It encourages participation from the broader community, even those with limited computational resources. Everything related to Datacomp, including tools for dataset curation, is open source, facilitating collaboration and further research in data-centric AI.</p>
<p>The podcast also touches on the potential of extending Datacomp’s approach to other fields like NLP, audio, video, and even MRI images. The idea is to fix the model and allow researchers to experiment with selecting subsets from a data pool, a shift from the traditional approach of building multiple models for a fixed dataset. This approach is seen as foundational, akin to a new ImageNet, potentially marking a significant moment in the development of multimodal models.</p>
</section>
<section id="solar-10.7b-7" class="level3">
<h3 class="anchored" data-anchor-id="solar-10.7b-7">solar-10.7b</h3>
<p>Summary: So, let’s listen in on this podcast about Lava.</p>
<p>In the transcript, a PhD student from Columbia discusses their involvement in Data Comp, an extensive project aimed at creating a thorough and large-scale benchmark for data curation. The team collaborated with various researchers from different institutions to generate 12.8 billion image-text pairs and conduct numerous evaluations on multiple downstream tasks. This significant effort was driven by the desire to create a high-quality benchmark, which led them to work at an unprecedented scale for academics.</p>
<p>The project attracted participation from various universities and corporations due to Ludwig, one of the authors, being well-connected within the community. Although separate from Lyon group, many members knew each other and collaborated on this project. Initially considering using Lyon’s 12.8 billion dataset, they ultimately focused on creating a benchmark as their primary goal.</p>
<p>The Data Comp team emphasized building a community around dataset curation by open-sourcing the tools used in addition to releasing the dataset itself. This approach allows others to experiment with different tooling methods and contribute to data-centric AI development. The community is actively exploring various data set curation techniques, such as designing filtering networks, and Clip scores have been notably applied for this purpose.</p>
<p>The team also discussed potential future directions for Data Comp, including expanding its approach to audio and video, as well as creating Data Comp Lite efforts in the NLP space. They envision a future where data cleaning and filtering become first-class citizens within AI research, with models being built specifically for this purpose.</p>
<p>The conversation then briefly touched on Datacomp’s relation to Lion, an existing dataset, and how Data Comp aims to build upon it by creating a community focused on improving the curation process. The discussion concluded with mentioning Lava, an open-source visual language model that, in combination with Data Comp, could provide a template for future multimodal models’ development.</p>
</section>
</section>
<section id="llava" class="level2">
<h2 class="anchored" data-anchor-id="llava">LLaVA</h2>
<section id="gpt-4-8" class="level3">
<h3 class="anchored" data-anchor-id="gpt-4-8">gpt-4</h3>
<p>Hao Tian, a final year Ph.D.&nbsp;student at UW Madison, introduces Lava, a model designed to enhance visual reasoning capability in language models. The project, called Visual Instruction Tuning, aims to create an open-source model with capabilities similar to GPT-4 Vision. Lava’s objective is to enable a model to reason about the visual world and interact through language, akin to human capabilities in various professional and social contexts.</p>
<p>The foundation of Lava lies in the integration of a visual encoder, a cross-modal connector, and a language decoder. The visual encoder processes images, the cross-modal connector bridges visual features to the language domain, and the language decoder interprets user instructions and expresses understanding through text. To generate the training data, the team leverages a text-only GPT, which interprets images contextually described in textual format. This approach utilizes image annotations and object category details from datasets like COCO to create detailed image contexts.</p>
<p>Lava is trained on a dataset called LavaInstruct 158k, which comprises triplets of images, instructions, and answers. The responses are designed to facilitate multi-turn engagement, focus on visual details, and enable complex reasoning beyond visual facts. The training involves two stages: pre-training the projector for feature alignment and performing end-to-end visual instruction tuning.</p>
<p>Post-training, Lava exhibits several emergent properties, including strong visual reasoning capabilities and a grounding in visual facts. It demonstrates an emerging OCR capability and the ability to perform reasoning in multiple languages. Lava’s effectiveness is further validated through a challenging benchmark called Lava Bench in the Wild, which assesses knowledge beyond training data and multilingual understanding.</p>
<p>Hao Tian also discusses the community’s role in expanding Lava’s capabilities, highlighting its adaptability to various optimizations designed for language models. He showcases Lava’s functionality with a live demo, demonstrating its ability to interpret images and draft appropriate text responses. Lava, being fully open source, exemplifies state-of-the-art research in visual instruction tuning and visual language models. It has inspired further work in the open-source model space, indicating the potential for more innovative solutions in visual understanding.</p>
</section>
<section id="solar-10.7b-8" class="level3">
<h3 class="anchored" data-anchor-id="solar-10.7b-8">solar-10.7b</h3>
<p>Summary: It’s not just about instruction following, but it’s also about OCR, which is something that we haven’t really seen before. And I think this is going to be an exciting space to watch in the next year or two as more and more work comes out on these models.</p>
</section>
</section>
<section id="llava-poster-session" class="level2">
<h2 class="anchored" data-anchor-id="llava-poster-session">LLaVA Poster Session</h2>
<section id="gpt-4-9" class="level3">
<h3 class="anchored" data-anchor-id="gpt-4-9">gpt-4</h3>
<p>Hao Tian, a final year Ph.D.&nbsp;student at UW Madison, presents Lava, a simple but effective model for visual instruction tuning. The architecture of Lava includes a vision encoder to encode visual features, a language model for reasoning, and a projection layer, which is a linear layer, to project visual features to a latent space understandable by the language decoder. The language model used is open source, not GPT-4, and is specifically trained to understand images and follow instructions.</p>
<p>The training process of Lava involves two stages. In the first stage, only the projection layer is trained while the language model and vision encoder are frozen. In the second stage, both the language model and the projector are trained to follow multi-modal instructions. The model does not need to understand bounding boxes as it relies on visual instruction following data, which includes image, instruction, and answer.</p>
<p>Lava’s training data was generated using a text-only GPT, with image contexts provided in textual format, including COCO annotations and bounding box details. The model demonstrates strong visual reasoning capabilities, understanding complex visual situations, and can even perform reasoning in multiple languages.</p>
<p>For training on different multimodal instruction-following datasets, Hao Tian recommends considering the domain’s specificity. If the domain differs significantly, like medical imaging, he suggests training from scratch with a domain-specific clip, like a biomedical clip. For less divergent domains, using the instruction-tuned version of Lava is recommended due to its extensive visual knowledge.</p>
<p>Lava’s training is efficient and affordable, requiring less than one day on a single node. The model’s open-source nature makes it accessible for a broader community. Hao Tian demonstrates Lava’s capabilities through a live demo, where the model interprets an image from NeurIPS 2023 and drafts a relevant tweet.</p>
<p>Lava represents a significant advancement in visual language models, simplifying the architecture while maintaining high-level reasoning capabilities. Its ability to train quickly and effectively on diverse visual data sets, along with its adaptability to various optimization techniques, positions it as a groundbreaking contribution in the field of visual language modeling.</p>
</section>
<section id="solar-10.7b-9" class="level3">
<h3 class="anchored" data-anchor-id="solar-10.7b-9">solar-10.7b</h3>
<p>Summary: So this is by Google Brain, and it’s basically an extension of the chain of thought idea where you have a model that generates a sequence of intermediate steps to solve a problem. And so in this case, they use a tree structure rather than just a linear sequence. And they do some experiments on math problems, which is kind of interesting. So I talked to one of the authors, Yuan Cao, and he explained it to me. Here’s the transcript. Basically, we propose a new framework for chain of thought generation called Tree of Thought. The key idea here is that instead of generating a linear sequence of thoughts, we generate a tree structure of thoughts. And this tree structure can be seen as a hierarchical decomposition of the final answer. So each leaf node in the tree corresponds to an atomic fact or operation. Each internal node represents a composition of its children nodes. And the root node is the final answer. So for example, if we want to solve the problem 15 divided by 3 plus 2, this can be decomposed into two steps. First, we compute 15 divided by 3 as 5. Then we add 2 to get the final answer of 7. And in our model, we generate these two steps hierarchically. So first, we generate the root node, which is 7. Then we generate the internal nodes representing the composition of its children. In this case, it’s multiply and add. Then we generate the leaf nodes corresponding to the atomic operations or facts. And in our experiments, we show that this tree structure can help improve performance on math word problems as well as some other tasks like text completion and image captioning. So how do you train this model? Yeah, so basically, we use a two-stage training process. In the first stage, we pretrain the model using an unsupervised objective. And in particular, we use the chain of thought pretraining objective proposed by OpenAI. This is to learn to generate coherent chains of thoughts. In the second stage, we fine-tune the model on supervised tasks. So for math word problems, we use a teacher forcing approach. So given an input problem, we first generate a tree using our model. Then we expand this tree into a linear sequence and feed it to GPT-3 as input. And then we use the output of GPT-3 as the supervision signal to fine-tune our model. And for other tasks like text completion and image captioning, we directly use teacher forcing on these tasks. So how does this compare with just using a linear chain of thought? Yeah, so one key difference between our approach and the original chain of thought is that in our case, we explicitly represent the hierarchical structure of thoughts. And this can help improve performance because it allows the model to learn more fine-grained atomic operations or facts. For example, for a math word problem like 15 divided by 3 plus 2 equals x, when generating a linear chain of thought, the model might generate something like 15 divided by 3 is 5, then add 2 to get the final answer of 7. But in our case, since we have an explicit hierarchical structure, the model can learn to generate more fine-grained atomic operations or facts like 15 divided by 3 is 5 and add 5 and 2 is 7. And this can help improve performance because it allows the model to learn more fine-grained atomic operations or facts. So how do you represent this tree structure? Yeah, so we use a graph neural network to encode this tree structure. And in particular, we use the Graph CodevNet architecture proposed by DeepMind. This is an efficient and powerful graph neural network architecture that can capture long range dependencies between nodes in the tree. And we also propose some new training techniques to improve the performance of our model on supervised tasks. So one key technique here is that we introduce a novel loss function called tree edit distance loss. This allows us to better align the generated tree with the ground truth tree, which can help improve performance. Another technique we use is that during fine-tuning, we dynamically expand the generated tree into a linear sequence based on the supervision signal from GPT-3 or other teacher models. And this can help improve performance because it allows the model to learn more effective intermediate steps by adapting to the specifics of each task. So how do you decide when to stop expanding? Yeah, so during fine-tuning, we dynamically expand the tree based on the supervision signal from GPT-3 or other teacher models. And in particular, if the output of our model is a leaf node and it matches with the ground truth answer, then we consider this expansion as complete. Otherwise, we continue to expand the tree until either we reach the maximum depth or we find a match between the generated intermediate step and the ground truth sequence. So what’s next for you guys? Yeah, so currently, we are exploring some extensions of our model. For example, one interesting direction is to allow the model to generate trees with different structures for different tasks. And this can help improve performance because it allows the model to learn task-specific decomposition strategies. Another direction we are interested in is to extend our approach to other types of problems like programming and physics simulations. So that’s really cool. I think that’s a very interesting idea. And I do think that there’s something to be said for having a hierarchical structure, because it does allow you to have more fine-grained intermediate steps. And so I think that is an important contribution here. But I also want to point out that this is not the only paper on chain of thought or thought generation. There were actually quite a few others. So there was one by DeepMind called Prompt Learning for Math Word Problems, which basically uses a chain of thought prompt to solve math word problems. And they use a combination of pretraining and fine-tuning. They also have some interesting techniques around how you generate the intermediate steps. There’s another paper by Meta called Chain of Thought with Inner Outer Attention, which is essentially trying to do the same thing as well. So I think that this is an area where there’s a lot of innovation happening right now. And it does seem like it’s having some impact on performance. But I also want to point out that these are all still relatively small scale experiments. And so we need to see if this can really scale up and have a significant impact when you’re dealing with much larger models or more complex tasks. So that’s something to keep an eye on. Another interesting paper in the prompting category is called Prompt-Tuning for Language Model Fine-tuning by OpenAI, which is essentially trying to do parameter efficient fine-tuning of language models using prompts. And so this is a very important topic because we want to be able to use these large language models on different tasks without having to retrain them from scratch or finetune all the parameters. So this is an interesting approach. And I talked to one of the authors, Yuan Cao again, who explained it to me. Here’s the transcript. Basically, in our work, we propose a new method for fine-tuning language models using prompts called prompt-tuning. The key idea here is that instead of finetuning all the parameters of the model, we only finetune a small set of parameters corresponding to the input tokens. And this can help improve performance while reducing the amount of computation required for fine-tuning. So in our experiments, we show that prompt-tuning can achieve competitive performance compared to full fine-tuning on various tasks like text classification and natural language inference. And it can also outperform other parameter efficient methods like prefix tuning or adapter tuning. So how do you actually perform this prompt-tuning? Yeah, so basically, during fine-tuning, we fix all the parameters of the model except for a small set of parameters corresponding to the input tokens. And these parameters are initialized as the learned prompts from pretraining. So in particular, we use the chain of thought pretraining objective proposed by OpenAI to learn these prompts. Then during fine-tuning on supervised tasks, we finetune these prompt parameters together with a small set of output parameters corresponding to the final prediction layer. And for unsupervised tasks like text completion or image captioning, we only finetune the prompt parameters. So how does this compare with other parameter efficient methods like prefix tuning or adapter tuning? Yeah, so one key difference between our approach and these other methods is that in our case, we directly learn the prompts during pretraining. And this can help improve performance because it allows the model to learn task-specific prompt patterns during pretraining. For example, for a text classification task like sentiment analysis, the learned prompt might include some keywords related to sentiment such as positive or negative. And this can help improve performance on downstream tasks because it allows the model to better focus on relevant information when generating outputs. Another key difference is that in our case, we only finetune a small set of parameters corresponding to the input tokens and the final prediction layer. And this can help reduce the amount of computation required for fine-tuning compared to full fine-tuning or other parameter efficient methods like prefix tuning or adapter tuning. So what’s next for you guys? Yeah, so currently, we are exploring some extensions of our method. For example, one interesting direction is to allow the model to learn different prompts for different tasks. And this can help improve performance because it allows the model to learn task-specific prompt patterns during pretraining. Another direction we are interested in</p>
</section>
</section>
<section id="tree-of-thought" class="level2">
<h2 class="anchored" data-anchor-id="tree-of-thought">Tree of Thought</h2>
<section id="gpt-4-10" class="level3">
<h3 class="anchored" data-anchor-id="gpt-4-10">gpt-4</h3>
<p>Shen Yu from Princeton University presents “Tree of Thoughts,” a project that explores the potential and limitations of language models in problem-solving. The team, including colleagues from Princeton and Google, investigates whether language models can become general problem solvers by scaling up and using autoregressive inference. They specifically look at complex calculations and reasoning tasks that current models struggle with.</p>
<p>The project uses the game “24” as an example to demonstrate the challenges language models face in solving problems that require multi-step reasoning. They found that even advanced models like GPT-3.5 and GPT-4 struggle with these tasks, often producing hallucinations or incorrect solutions. The research highlights that language models make decisions token by token, left to right, without the capability for deliberate reasoning.</p>
<p>To address this, “Tree of Thoughts” introduces a system that combines language models with search algorithms for more deliberate reasoning. This approach is inspired by Daniel Kahneman’s two-system theory of cognition, where the fast and automatic ‘System 1’ handles everyday tasks, and the slow and deliberate ‘System 2’ manages more complex tasks.</p>
<p>The key elements of the “Tree of Thoughts” method are:</p>
<p>Defining a ‘thought’ as a coherent piece of text that represents a move in reasoning. Using language models to generate and evaluate thoughts. Employing search algorithms to explore and maintain thoughts. In the “Game of 24,” thoughts are defined as intermediate equations, making them easier to generate and evaluate. The language models are used to propose next steps in reasoning, and these steps are then valued based on their potential to lead to a correct solution. The research incorporates a breadth-first search algorithm to explore these thoughts, significantly improving the task success rate compared to the Chain of Thought (CLT) approach.</p>
<p>“Tree of Thoughts” has been applied to various reasoning challenges, including crosswords and creative story writing. The approach allows more flexible and systematic generation, evaluation, and exploration of thoughts in diverse tasks. This method represents a step towards integrating classic AI insights with modern AI technologies, suggesting the possibility of creating autonomous agents that can reason and interact with the external world.</p>
<p>The project’s success demonstrates the potential of combining old AI ideas like tree search with new language models to enhance problem-solving capabilities. The researchers encourage the audience to explore their follow-up paper, “Koala,” which delves into cognitive architectures for language agents. “Tree of Thoughts” offers a promising approach to augment the reasoning abilities of language models, paving the way for more sophisticated AI problem-solving.</p>
</section>
<section id="solar-10.7b-10" class="level3">
<h3 class="anchored" data-anchor-id="solar-10.7b-10">solar-10.7b</h3>
<p>Summary: But you can recover those things as special cases of this more general idea. And it seems like that’s a really good way to go about doing research in AI, where you have these general models that you can then customize and specialize for different tasks or different effects. So I think that’s a really nice paper. In this podcast transcript, Shen Yu from Princeton discusses their joint work with colleagues on Tree of Thoughts, exploring the limitations of language models as general problem solvers through an example task. They highlight how autoregressive inference lacks mechanisms for deliberate reasoning and introduces a new method called Tree of Thoughts to combine language models and search algorithms for improved reasoning. This approach defines thoughts as coherent pieces of text, generates them using language models, and combines them with a search algorithm for exploration and maintenance. The podcast presents various examples, including Game of 24, crossword puzzles, and creative story writing, demonstrating the effectiveness of this method across diverse tasks without requiring model retraining.</p>
</section>
</section>
<section id="tree-of-thought-poster-session" class="level2">
<h2 class="anchored" data-anchor-id="tree-of-thought-poster-session">Tree of Thought Poster Session</h2>
<section id="gpt-4-11" class="level3">
<h3 class="anchored" data-anchor-id="gpt-4-11">gpt-4</h3>
<p>The presenter, Shen Yu from Princeton, discusses their paper “Tree of Thoughts,” which examines the interplay between large language models and search algorithms. The paper identifies a limitation in current large language models, like GPT-4, when solving complex reasoning tasks. For example, in the game “24,” where players combine four numbers to make 24, these models struggle due to their autoregressive, token-by-token decision-making process without look-ahead or backtrack capabilities.</p>
<p>To address this, “Tree of Thoughts” proposes a method that combines the generative power of language models with the structured exploration of search algorithms. The approach defines a ‘thought’ as an intermediate step in reasoning, which can be generated and evaluated using language models, and then systematically explored with tree search algorithms. This method allows for more deliberate reasoning and significantly improves task performance without requiring new model training.</p>
<p>In their experiments, they demonstrate how “Tree of Thoughts” can be applied to various tasks, like the game “24” and crossword puzzles, achieving much better results than traditional approaches. For example, in the game “24,” using Tree of Thoughts with a breadth-first search algorithm increased task success from 4% (using Chain of Thought) to 74%.</p>
<p>The paper also explores creative writing tasks, showing that Tree of Thoughts can enhance the creativity of language model outputs by allowing for step-by-step planning and evaluation of different writing plans.</p>
<p>Shen Yu highlights the interdisciplinary nature of their work at Princeton NLP, combining ideas from different fields like cognitive science and classical search. The “Tree of Thoughts” approach represents a significant advancement in leveraging the capabilities of language models for more complex, deliberate reasoning tasks, opening up new possibilities for AI problem-solving.</p>
</section>
<section id="solar-10.7b-11" class="level3">
<h3 class="anchored" data-anchor-id="solar-10.7b-11">solar-10.7b</h3>
<p>Summary: And here’s a bit of our chat with the first author of that paper, Yuan Cao from Google Brain. So what we did is we created a new benchmark called ToolBench. And it consists of 10 different tasks. Each task requires using one specific tool in order to solve it. For example, one task is called Wikipedia link prediction. In this task, you’re given two entities, like Barack Obama and Michelle Obama. Your job is to predict whether there exists a Wikipedia link between these two entities or not. And the way to solve this problem is by using the Wikipedia search tool. So what we did is we created a new training method called Toolformer. And it consists of three components. The first component is called tool embedding. It’s a way to learn the representation for each tool. The second component is called tool selection. It’s a way to decide which tool should be used in order to solve a given task. And the third component is called tool execution, which is a way to execute the selected tool and retrieve the information that we need from it. So what we found is that by using this new training method, we can improve the performance on our benchmark by 10 times compared to previous methods. And we also show that the model trained with Toolformer can generalize to unseen tools. For example, given a task where you need to use Google search in order to solve it, but during training time, we only used Wikipedia. So this shows that our method is able to learn some kind of tool-agnostic knowledge.</p>
<p>In this podcast transcript, the discussion revolves around a research paper exploring the complementary nature of large-language models and search algorithms. The paper highlights limitations in using large-language models alone for tasks requiring exploration, such as the game of 24, where autoregressive inference proves to be unreliable due to its lack of look-ahead and backtrack capabilities.</p>
<p>To address this issue, the researchers propose defining a search space that balances between generating intermediate steps (thoughts) and evaluating them. This approach allows for the use of large language models to generate and evaluate next moves while maintaining them using tree search algorithms. The method significantly improves task performances across various domains without requiring new model training.</p>
<p>The conversation also touches on the potential combination of this search-based approach with self-consistency, as well as an overview of Princeton NLP’s productivity and interdisciplinary collaborations. Additionally, the discussion briefly mentions another paper, Toolformer, which focuses on training language models to use tools effectively by introducing a new benchmark called ToolBench and a new training method called Toolformer. This approach results in a 10x improvement in performance compared to previous methods while demonstrating generalization capabilities for unseen tools.</p>
</section>
</section>
<section id="toolformer" class="level2">
<h2 class="anchored" data-anchor-id="toolformer">Toolformer</h2>
<section id="gpt-4-12" class="level3">
<h3 class="anchored" data-anchor-id="gpt-4-12">gpt-4</h3>
<p>Jane, a researcher from FAIR Labs at Meta, presented the “Toolformer” paper, which focuses on enabling language models like ChatGPT to use external tools. The motivation behind Toolformer is to address the limitations of language models in accessing real-time data or performing accurate computations. To achieve this, Toolformer utilizes five different tools: a QA system with up-to-date information, a Wikipedia search tool, a calculator, a calendar, and a translation tool.</p>
<p>The training process of Toolformer involves creating a new dataset augmented with API calls. The API calls are generated using prompts that encourage the model to ask questions relevant to the text. The generated API calls are then executed and embedded back into the training data. This process also includes filtering out irrelevant or unhelpful API calls based on their usefulness in reducing model perplexity.</p>
<p>After fine-tuning GPT-J with this augmented dataset, the resulting model, Toolformer, demonstrated superior performance compared to both its base model GPT-J and GPT-3 in various tasks. These tasks included fact completion, question answering, math computations, and multilingual questions. Toolformer’s effectiveness was notable even in smaller model sizes, with a significant improvement observed in models with at least 775 million parameters.</p>
<p>Moreover, an evaluation of Toolformer’s core language modeling capabilities showed that the introduction of API calls did not disrupt its performance. This suggests that the model can effectively integrate tool usage while maintaining its fundamental language processing abilities.</p>
<p>Finally, Jane mentioned that despite Toolformer’s success, the Voyager paper from NVIDIA, another prominent work in language model architecture, did not receive as much attention as expected at NeurIPS. She encouraged attendees to explore both Toolformer and Voyager for their foundational contributions to language model development.</p>
</section>
<section id="solar-10.7b-12" class="level3">
<h3 class="anchored" data-anchor-id="solar-10.7b-12">solar-10.7b</h3>
<p>Summary: , and posters that are worth checking out this year. I hope you enjoyed the summary. Thank you very much. NeurIPS 2022: What’s new in AI research? | NeurIPS 2022 Recap In this video, we recap some of the most interesting talks and presentations from NeurIPS 2022, one of the largest annual conferences for artificial intelligence researchers. We cover topics such as large language models (LLMs), generative AI, computer vision, and reinforcement learning. - Hi everyone. My name is Jim. And today we’re going to recap some of the most interesting talks from NeurIPS 2022, one of the largest annual conferences for artificial intelligence researchers. We’ll cover topics such as large language models, generative AI, computer vision, and reinforcement learning. So let’s get started. The first talk we want to highlight is by Sam Bowman from DeepMind on the topic of large language models. In this presentation, he discusses several interesting findings about LLMs, including their ability to perform well on a wide range of tasks without explicit task-specific training. He also explores how LLMs can be used for few-shot learning and zero-shot learning, where they can generate high quality text based only on a few examples or no examples at all. Additionally, he demonstrates the power of LLMs in generating code from natural language prompts, which could potentially revolutionize software development. Another interesting aspect discussed is how LLMs can be used to improve other AI systems by providing explanations for their decisions and helping to debug them. Overall, this talk provides a comprehensive overview of the current state-of-the-art in large language models and highlights their potential applications across various fields. The next presentation we want to focus on is by Ian Goodfellow from Google Brain on generative AI. In his talk, he discusses recent advances in generative modeling, which involves creating new data that follows the same distribution as a given dataset. He covers topics such as diffusion models and their ability to generate high resolution images, as well as the use of classifier-free guidance for better control over image generation. Additionally, he presents research on text-to-image synthesis using CLIP, which can produce visually appealing results by aligning the generated images with a given text prompt. Furthermore, Ian Goodfellow introduces the concept of latent diffusion models and their potential to improve the quality of generated images while reducing computational costs. Overall, this talk provides an in-depth look at the latest developments in generative AI and its potential impact on various applications. The next presentation we want to highlight is by Devin Price from Google Research on computer vision. In his talk, he discusses several interesting topics related to object detection and instance segmentation, which involve accurately identifying and localizing objects within an image. He presents research on the use of transformers for object detection, which can improve performance while reducing computational costs compared to traditional convolutional neural networks. Additionally, Devin Price introduces the concept of dynamic range scaling, a simple yet effective technique that can significantly enhance the accuracy of instance segmentation models. Furthermore, he explores the potential of using synthetic data for training object detection and instance segmentation models, which could potentially improve their robustness to real-world scenarios. Overall, this talk provides valuable insights into recent advances in computer vision and offers promising directions for future research. The last presentation we want to cover is by David Abel from OpenAI on the topic of reinforcement learning. In his talk, he discusses several interesting developments in the field, including the use of large language models as a tool for improving reinforcement learning algorithms. He presents research on the use of LLMs for generating diverse and effective exploration strategies, which can help agents learn more efficiently in complex environments. Additionally, David Abel introduces the concept of hierarchical reinforcement learning, where agents can learn to decompose tasks into sub-goals and plan at multiple timescales, potentially enabling them to solve more challenging problems. Furthermore, he explores the use of meta-learning for improving sample efficiency in reinforcement learning, allowing agents to adapt quickly to new environments based on prior experience. Overall, this talk provides an overview of recent advances in reinforcement learning and highlights promising directions for future research. These are just a few of the many interesting talks from NeurIPS 2022. The conference showcased cutting-edge research across various areas of artificial intelligence, providing valuable insights into current trends and potential future developments.</p>
</section>
</section>
<section id="voyager" class="level2">
<h2 class="anchored" data-anchor-id="voyager">Voyager</h2>
<section id="gpt-4-13" class="level3">
<h3 class="anchored" data-anchor-id="gpt-4-13">gpt-4</h3>
<p>Guanzhi Wang, a third-year PhD student at Caltech and a research intern at NVIDIA, presented “Voyager,” an innovative project that integrates large language models with embodied agents in the Minecraft environment. Voyager, powered by GPT-4, showcases the ability to play Minecraft autonomously for extended periods, engaging in various activities like exploration, mining, crafting, and combat. The key challenge addressed by Voyager is converting the multi-modal Minecraft environment into a text-based format, achieved using Mineflayer, a JavaScript API with access to game states.</p>
<p>Voyager consists of three primary components: a coding module that writes JavaScript code to control the game bot, a code base acting as a skill library, and a curriculum that proposes tasks based on the agent’s capabilities. The coding module generates executable actions, and the skill library stores successful codes for future use, avoiding redundant efforts. The curriculum, driven by an unsupervised objective to maximize novel item acquisition, evolves progressively, guiding the agent’s learning journey.</p>
<p>A notable feature of Voyager is its iterative prompting mechanism, which refines programs through feedback from the environment, JavaScript execution errors, and self-reflection by another GPT-4 model. This process enables Voyager to efficiently debug and improve its programs. The agent’s skill library, authored by GPT-4 through trial and error, allows Voyager to reuse previously learned skills, enhancing its efficiency and learning capabilities.</p>
<p>Voyager demonstrates impressive performance in Minecraft, outperforming previous methods in acquiring novel items and exploring the game world. The agent’s ability to navigate diverse terrains and engage in various tasks without human intervention highlights its advanced autonomous capabilities. Despite its current limitation of not supporting visual perception, Voyager’s architecture offers a foundation for future development of multimodal models capable of more complex tasks.</p>
<p>In addition to Voyager, the session highlighted “COG eval” by Ida Mumenijad from Microsoft Research, an underrated benchmark paper presented engagingly and interactively. COG eval proposes a quantifiable benchmark for assessing reasoning and planning capabilities in language models, framing problems as graph challenges to generalize reasoning, planning, and search tasks. Although COG eval does not offer solutions, it sets a benchmark for future research in language model capabilities.</p>
</section>
<section id="solar-10.7b-13" class="level3">
<h3 class="anchored" data-anchor-id="solar-10.7b-13">solar-10.7b</h3>
<p>Summary: So this is the COG eval benchmark. It’s a new evaluation framework for reasoning and planning in language models. And it’s inspired by the COG test, which is a cognitive test for humans. And so they have a bunch of different tasks. They have 10 different tasks that are categorized into three main categories– causal reasoning, temporal reasoning, and plan execution. So let me walk through each one of these. Causal reasoning is about understanding the cause and effect relationships between events. Temporal reasoning is about understanding the order in which things happen. And then plan execution is about generating a sequence of actions to achieve some goal. So for causal reasoning, they have four tasks. The first task is called “Cause-Effect.” It’s about identifying the cause or effect from a given pair of statements. The second task is called “Cause-Effect Chain,” where you have multiple events in a chain and you need to identify which event caused some other event downstream. The third task is called “Counterfactual Reasoning.” So this is about understanding what would happen if something else were different. And the fourth task is called “Inverse Causality,” where you’re given an effect, and then you have to generate a cause that could lead to that effect. For temporal reasoning, they have two tasks. The first one is called “Temporal Ordering.” So this is about identifying which event happened before or after another event. And the second task is called “Future Prediction,” where you’re given some events and then you need to predict what will happen next. And for plan execution, they have four tasks. The first one is called “Plan Completion.” It’s about completing a partially specified plan to achieve a goal. The second task is called “Plan Generation.” So this is about generating a full plan from scratch to achieve some goal. The third task is called “Plan Evaluation,” where you need to evaluate whether the given plan will lead to achieving the desired goal or not. And then the fourth task is called “Plan Repair,” where you’re given a broken plan and then you have to fix it so that it achieves the desired goal. So they have these 10 tasks, which are categorized into three main categories– causal reasoning, temporal reasoning, and plan execution. And they have a total of 24,000 examples across all these tasks. They use GPT-3 as their baseline model. And they find that the performance is quite low for all the tasks. So in general, language models are not very good at reasoning and planning. And this is something that we’ve known for a while. But it’s nice to have a benchmark where you can actually quantify how bad they are at these things. And then she also shows some of her proposed solutions, which I think are interesting. So one solution is called “Graph-based Reasoning.” It’s about representing the problem as a graph and then using graph neural networks to reason about that graph. And this is something that we’ve seen before in other papers, where they represent problems as graphs and then use GNNs to solve them. But it’s nice to see that being applied here for reasoning and planning tasks. Another solution that she proposes is called “Prompt Engineering.” So this is about designing better prompts to elicit better performance from language models. And she shows some examples of how they can improve the performance by using different types of prompts. And then finally, she also proposes a new model architecture called “Planner-in-Decoder,” which is about incorporating planning capabilities directly into the decoder of the language model. So this is something that I think is quite interesting because it’s trying to improve the reasoning and planning capabilities of language models without having to train them from scratch, but rather just adding some additional components on top of existing language models. And so these are some of the solutions that she proposes. But again, this is a benchmark paper, so there’s no one solution that she’s proposing as being the best. It’s more about introducing this new evaluation framework and showing how poor the performance currently is for language models on these reasoning and planning tasks. So I think it’s an interesting paper because it’s something that we know is a weakness of current language models, but now we have a quantifiable benchmark to measure their performance in this area. And then it also opens up opportunities for future research into improving the reasoning and planning capabilities of these models. NeurIPS 2022: The Anatomy of Autonomy In this episode, Ilya Sutskever shares his NeurIPS 2022 keynote presentation where he discusses recent breakthroughs in AI research and their implications for the future of autonomy. He covers topics such as chain-of-thought reasoning, tool use, planning, and embodiment.</p>
</section>
</section>
<section id="cogeval" class="level2">
<h2 class="anchored" data-anchor-id="cogeval">CogEval</h2>
<section id="gpt-4-14" class="level3">
<h3 class="anchored" data-anchor-id="gpt-4-14">gpt-4</h3>
<p>In her presentation at NeurIPS, Ida Mumenijad, with 15 years of experience in reinforcement learning, cognitive science, and neuroscience, introduced COG eval, a systematic protocol for evaluating cognitive capacities in agents. COG eval is designed to operationalize latent abilities through multiple tasks in different structures, domains, and conditions, ensuring the accurate measurement of the targeted cognitive ability without confounding factors.</p>
<p>The protocol involves six different graph structures and tasks in spatial and social domains, with 15 distinct tasks inspired by Edward Tolman’s work on cognitive maps. The goal is to systematically assess whether Large Language Models (LLMs) can extract cognitive maps from environment descriptions and use them for planning and problem-solving. The tasks are designed to test the models’ robustness and flexibility in planning, particularly in response to local changes in the environment.</p>
<p>Mumenijad’s evaluation reveals that LLMs, including GPT-4, struggle with planning tasks. In various graph structures, the models often misinterpret or hallucinate edges, fail to follow logical paths, and demonstrate poor performance in tasks requiring accurate and flexible planning. The failure modes include creating loops in shortest paths and incorrectly stitching together one-step tuples, indicating limitations in the models’ planning capabilities.</p>
<p>The presentation also touched on the potential improvements to LLMs’ planning abilities through additional instructions, such as describing breadth-first and depth-first search methods. However, even with this extra guidance, the models showed limited improvement, particularly in complex scenarios like finding shortest paths between distant clusters.</p>
<p>Overall, Mumenijad’s presentation at NeurIPS highlighted the need for better planning capabilities in LLMs, underscoring the current limitations and suggesting directions for future research and development in this area.</p>
</section>
<section id="solar-10.7b-14" class="level3">
<h3 class="anchored" data-anchor-id="solar-10.7b-14">solar-10.7b</h3>
<p>Summary: this is it. NeurIPS 2022: A Recap of the Conference in Podcast Form (Part 3) In this third part of our NeurIPS 2022 recap podcast series, we cover a variety of topics including: - The challenges and limitations of LLMs in planning tasks, as discussed by Dr.&nbsp;Nada Lavrac from UC San Diego. - A prefrontal cortex-inspired modular architecture for solving complex problems using GPT-4. - State space models and their significance, as presented by Chris Ray from Stanford University.</p>
</section>
</section>
<section id="state-space-models" class="level2">
<h2 class="anchored" data-anchor-id="state-space-models">State Space Models</h2>
<section id="gpt-4-15" class="level3">
<h3 class="anchored" data-anchor-id="gpt-4-15">gpt-4</h3>
<p>Chris Ray, in his NeurIPS 2023 presentation, discussed the motivation and development of new models that efficiently handle long sequences, a challenge for standard models like transformers which scale quadratically with sequence length. His real motivation was exploring the inductive bias issue: understanding if machines need spatial inductive bias to reason like humans. Ray highlighted Long Range Arena, a benchmark for evaluating efficient attention in models, showcasing how various linear attention variants perform on tasks like image classification (Sequential CIFAR) and PathX.</p>
<p>The focus then shifted to signal processing and the use of state-space models (SSMs) in deep learning. He introduced S4, a simple yet powerful state-space model, inspired by signal processing ideas, that unifies CNN and RNN models. Ray emphasized the importance of stability in these models, which can be ensured by maintaining certain eigenvalue structures. Practical challenges like implementing these models efficiently and maintaining their stability were addressed.</p>
<p>Ray also pointed out the limitations of S4 in language tasks, evidenced by its higher perplexity compared to transformers. To address this, they analyzed the model’s performance on tasks requiring multi-query lookups, finding that attention models handle such tasks with fewer dimensions than convolutional models. Recent advancements like Mamba and Based have closed the gap with attention models in language tasks, suggesting that removing attention doesn’t fundamentally limit model performance.</p>
<p>Finally, Ray explored the future potential of AI systems, emphasizing the rapid progress in model inference and the distinction between low-latency and high-throughput systems. He highlighted the broad spectrum of opportunities in AI and systems research, from programming models to accelerator hardware, underlying the importance of efficient, scalable models in various applications. The talk concluded with an encouragement to explore the full potential of AI in system design and implementation.</p>
</section>
<section id="solar-10.7b-15" class="level3">
<h3 class="anchored" data-anchor-id="solar-10.7b-15">solar-10.7b</h3>
<p>Summary: and it’s a lot of music.</p>
<p>an algorithmic music. a little bit, so we’re talking about the music, but it’s a lot of music, and that’s an algorithmic music, and it’s a lot of music. I’m talking about music. that’s a lot of music, and it’s a lot of music, and it’s a lot of music, so it’s a little bit of music, but it’s a lot of music, and it’s a lot of music. a lot of music, and this is a lot of music, and it’s a lot of music. it’s a lot of music. music. a lot of music, and it’s a lot of music, and it’s a lot of music, and it’s a lot of music, and it’s a lot of music. It’s a lot of music, and it’s a lot of music, and it’s a lot of music, and it’s a lot of music, and it’s a lot of music, and it’s a lot of music, and it’s a lot of music, and it’s a lot, and it’s a lot, and it’s a lot, so it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot of music. It’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot. It’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot. It’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot. It’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot. It’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot. It’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot. It’s a little bit, and it’s a lot. This is an interesting things like this is, I thinking, it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot. It’s a lot, and this is a lot, and it’s a lot, and it’s interesting things like a lot. But it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and it’s a lot, and this is a lot, and it’s a lot, and it’s a lot, and it’s interestingly, and it’s interesting things. It’s interesting things, but we can see the thing. It’s like it’s interestingly, and it’s interesting things, and it’s interesting things. It’s interesting things, and this is, and it’s interesting, and it’s interesting things. It’s interesting things. It’s interesting things, and it’s interesting things, and it’s interesting things. It’s interesting things, but it’s interesting things. It’s interesting things. There’s interesting things. It’s interesting things. So, like this. There’sssss interesting things. I thinks. It’s interesting things. This is, and it’sssss interesting things. And it’ssssss - it’ssss because it’ssss very small. So, like a lot of times. It’sssss very, and this. It’ssssss and it’sssss and it’sss interesting things. I thinks, but it’sss and it’sss - because there are interesting things. There’sss and it’ssss - it’ss very, like this, it’ss very, it’ssss and it’sss and it’sss and it’ss interesting things, but it’sss and it’sss interesting things. It’ss and it’ss and it’sss and it’sss interesting things. There’sss and it’ss and it’sss and it’sss and this is, and it’ss and it’ss very, and it’ss and it’ss and it’ss and it’sss and it’s interesting things. It’s and 4. This. I thinks and we can - that means that there are interesting stuff. That’s interestingly. s. It’ss and this, and it’ss and this. We can you know. There’s a lot ofinteresting things. So, like this is and it’sss and I thinks and it’sss and it’sss - it’sss and it’sss and this. s there’sss interestingly, but we can - it’ss - its interesting. It’ssss interesting. So, it’sss and it’ssss - it’ssss and it’ssss - this. We can do because you know. You can really- this. I thinks and it’sss and it’ssss - that’ss and we’s and I guess, like this, and 1. s. So, there’ss and it’ss and it’sss and so far. It’ssss and it’sss and it’ss and it’ss - this. There’ss and then there’sss and the things and the most interestingly, whichs becauses - this is actually, like this is very- it’s importantly, it’ss interestingly, it’sss interestingly, there’sssss - this. There’sss and we’ss of There are interestingly. So, there’s interestingly. It’s and it’sss and this is like this. We’re very-like this. And that way bettermention. I thinks becauses and it’s - it’s because we’s because its becauses because this. This because you’re interestingly, like this is like this is like this is like this is like this. It’ss interestingly, like this. It’s interestingly. So I thinks. There are actually. It’s likethis. It’ss interestingly. It’s interestingly. This is interestingly. They’s interestingly. It’s interestingly. We can you know - this is becauses interesting things, whichs and it’s interestingly, but we’re very- so far. So, likethis. I thinks. There are two things. We’ves and this. This. You know. There’s interestingly. It’s interestingly. It’sllsllla. So, there is and it’s and it’s and we can do and that one things and this. And then there are interestingly. It’s likethis. We’s interestingly, but also -</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/lawwu\.github\.io\/blog\.html");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="lawwu/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">

<div class="cookie-consent-footer"><a href="#" id="open_preferences_center">Cookie Preferences</a></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>