---
title: "Introduction to LangGraph Tutorial"
author: "Lawrence Wu"    
date: "2024-09-20"
categories: ["LangGraph", "LLMs", "Agents", "Python"]
draft: true
---

The LangChain team recently released the first course in their LangChain Academy called Introduction to LangGraph ([repo](https://github.com/langchain-ai/langchain-academy)). As I'm working through it I will make some notes on what I've learned. Note many of these snippets were generated using Claude 3.5 Sonnet (passing a prompt and the Jupyter notebook plain text, it did a better job than `o1-preview`, surprisingly)

## Module 2 - State and Memory

### Lesson 2 - State Reducers

[Notebook](https://github.com/langchain-ai/langchain-academy/blob/8cca5e1092d01931f6aa9143ffc87d21ccd6052f/module-2/state-reducers.ipynb)

Reducers are used to specify how state updates are performed when multiple nodes try to update the same key:

```python
from typing import Annotated
from operator import add

class State(TypedDict):
    foo: Annotated[list[int], add]
```

Custom reducers can be defined to handle complex state update logic:

```python
def reduce_list(left: list | None, right: list | None) -> list:
    if not left:
        left = []
    if not right:
        right = []
    return left + right

class CustomReducerState(TypedDict):
    foo: Annotated[list[int], reduce_list]
```

MessagesState is a useful shortcut for working with message-based states. These two are equivalent:

```python
from typing import Annotated
from langgraph.graph import MessagesState
from langchain_core.messages import AnyMessage
from langgraph.graph.message import add_messages

# Define a custom TypedDict that includes a list of messages with add_messages reducer
class CustomMessagesState(TypedDict):
    messages: Annotated[list[AnyMessage], add_messages]
    added_key_1: str
    added_key_2: str
    # etc

# Use MessagesState, which includes the messages key with add_messages reducer
class ExtendedMessagesState(MessagesState):
    # Add any keys needed beyond messages, which is pre-built 
    added_key_1: str
    added_key_2: str
    # etc
```

The `add_messages` reducer allows appending messages to the state:

```python
from langgraph.graph.message import add_messages
from langchain_core.messages import AIMessage, HumanMessage

new_state = add_messages(existing_messages, new_message)
```

Messages can be overwritten by using the same ID:
```python
new_message = HumanMessage(content="New content", name="User", id="existing_id")
updated_state = add_messages(existing_messages, new_message)
```

Messages can be removed using `RemoveMessage`:
```python
from langchain_core.messages import RemoveMessage

delete_messages = [RemoveMessage(id=m.id) for m in messages_to_delete]
updated_state = add_messages(existing_messages, delete_messages)
```

### Lesson 3 - Multiple Schemas

[Notebook](https://github.com/langchain-ai/langchain-academy/blob/8cca5e1092d01931f6aa9143ffc87d21ccd6052f/module-2/multiple-schemas.ipynb)

A graph can have multiple states. This is useful for controlling what information is shown to the user.

Private State: You can pass private state between nodes that isn't relevant for the overall graph input or output.

```python
from typing_extensions import TypedDict
from IPython.display import Image, display
from langgraph.graph import StateGraph, START, END

class OverallState(TypedDict):
    foo: int

class PrivateState(TypedDict):
    baz: int

def node_1(state: OverallState) -> PrivateState:
    print("---Node 1---")
    return {"baz": state['foo'] + 1}

def node_2(state: PrivateState) -> OverallState:
    print("---Node 2---")
    return {"foo": state['baz'] + 1}

# Build graph
builder = StateGraph(OverallState)
builder.add_node("node_1", node_1)
builder.add_node("node_2", node_2)

# Logic
builder.add_edge(START, "node_1")
builder.add_edge("node_1", "node_2")
builder.add_edge("node_2", END)

# Add
graph = builder.compile()
```

Input/Output Schema: You can define explicit input and output schemas for a graph, which is useful for constraining the input and output. Filtering: Input and output schemas perform filtering on what keys are permitted on the input and output of the graph.

```python
class InputState(TypedDict):
    question: str

class OutputState(TypedDict):
    answer: str

class OverallState(TypedDict):
    question: str
    answer: str
    notes: str

def thinking_node(state: InputState):
    return {"answer": "bye", "notes": "... his is name is Lance"}

def answer_node(state: OverallState) -> OutputState:
    return {"answer": "bye Lance"}

graph = StateGraph(OverallState, input=InputState, output=OutputState)
graph.add_node("answer_node", answer_node)
graph.add_node("thinking_node", thinking_node)
graph.add_edge(START, "thinking_node")
graph.add_edge("thinking_node", "answer_node")
graph.add_edge("answer_node", END)

graph = graph.compile()

# View
display(Image(graph.get_graph().draw_mermaid_png()))

graph.invoke({"question":"hi"})
# Output: {'answer': 'bye Lance'}
```